# 5. Необхідно обчислити корінь квадратного рівняння.
# a · x2 + b · x + c = 0
# Дискримінант рівняння помістіть у змінну D
# D = b2 - 4 · a · c
# Корінь рівняння помістіть у змінні x1 та x2
# x1 = (-b + D0.5) / (2 · a)
# x2 = (-b - D0.5) / (2 · a)
import math

a = int(input("Enter coefficient a: "))
b = int(input("Enter coefficient b: "))
c = int(input("Enter coefficient c: "))

D = b ** 2 - 4 * a * c

if D>0:
    x1 = (-b + math.sqrt(D)) / (2 * a)
    x2 = (-b - math.sqrt(D)) / (2 * a)

# 6. Виконайте завдання, щоб визначити парне число чи ні, за допомогою тернарного оператора.
# Програма встановлює значення змінної is_even у True або False, залежно від того, чи 
# є число в змінній num парним або непарним.
# Підказка: перевірка на парність виконується порівнянням залишку від поділу на 2 з 0 або 1. 
# Нагадаємо, залишок від ділення можна отримати після операції %

num = int(input("Enter an integer number: "))

is_even = True if not num % 2 else False

# 7. Користувач вводить число від 0 до 100. Підрахуйте, використовуючи цикл while, суму всіх чисел 
# від першого до введеного числа включно в num. Результат помістити в змінну sum.
# Тести будуть:
# Поміщати тестові значення для змінної num: 20, 10, 5, 100
# І чекати суми в змінній sum: 210, 55, 15, 5050

num = int(input("Enter the integer (0 to 100): "))
sum = 0
i=0
while i<=num:
    sum += i;
    i +=1;


# 8. Рядок — це об'єкт, що ітерується, а, значить, ми можемо використовувати його в циклі for. 
# Підрахуйте в заданому рядку message кількість входжень символу зі змінної search. 
# Результат помістіть у змінну result.

message = "Never argue with stupid people, they will drag you down to their level and then beat you with experience."
search = "r"
result = 0
for char in message:
    if char==search:
        result +=1

# 9. На співбесідах часто люблять запитувати про алгоритми. Наприклад, розрахуйте найбільший 
# спільний дільник (НД) двох додатних чисел. НСД — це найбільше число, на яке без залишку діляться обидва числа.
# Є кілька алгоритмів знаходження НСД, але ми розберемо циклічний алгоритм
# Хай є два початкових числа first та second.
# Виберемо менше з них та привласнимо значення змінній gcd.
# Поки first або second не діляться на gcd без залишку, треба виконувати цикл, в якому зменшуємо змінну gcd на одиницю.
# Коли цикл закінчиться в змінній gcd буде НСД для чисел first та second
# Напишіть програму, яка для двох додатних цілих чисел знаходить НСД.
# Примітка: Для умови циклу в пункті 3 необхідно пам'ятати, що цикл while виконується за умови True, 
# а наш цикл повинен закінчитися, тільки якщо gcd поділив обидва числа без залишку.

first = int(input("Enter the first integer: "))
second = int(input("Enter the second integer: "))

gcd = first if first<second else second
while (first%gcd!=0 or second%gcd!=0) and gcd >0:
    gcd -=1;
    

# 13. Досить часто програмісти стикаються із завданнями кодування інформації. Закодувати повідомлення в 
# чаті між двома користувачами. Зашифрувати пароль та ім'я користувача при автентифікації користувача 
# через мережу і т.і.
# Напишіть програму, що реалізує код Цезаря. Він названий на честь великого римського імператора Юлія Цезаря.
# Ідея шифрування полягає у циклічному зміщенні букв на задану кількість. Наприклад, якщо зміщення на три 
# позиції, то літера A стає літерою D, B – E тощо. Останні три літери алфавіту зациклюються та переносяться 
# на початок. Літера X стає A, Y – B, а Z – C. Цифри, пробіли та інші символи не шифруються.
# У програмі користувач вводить фразу та число для зсуву, після чого треба вирахувати нове закодоване повідомлення.
# Програма шифруватиме як малі (a-z), так і великі літери (A-Z).
# Для розв'язку цього завдання знадобиться знання двох нових функцій. Перша функція ord. Вона перетворює 
# символ на число, яке є позицією в таблиці ASCII.
# ord("a")  # 97
# Можна вважати, що отриманий результат '97' — це числове представлення символу a для комп'ютера.
# Зворотна функція chr повертає рядковий символ у таблиці ASCII за позицією, переданою як аргумент.
# 
# chr(118)  # 'v'
# 
# Детальніший принцип шифрування.
# Розглянемо для прикладу як зашифрувати символ v. Щоб отримати позицію символу v щодо початкового символу a,
# необхідно виконати вираз
# 
# pos = ord('v') - ord('a')  # 21
# 
# Але, згідно з алгоритмом, нам необхідно враховувати зсув, який може бути довільним, наприклад, 33. І пам'ятати, 
# що алфавіт англійської мови заснований на латинському алфавіті та складається з 26 літер. Тому кінцева позиція 
# символу v щодо символу a для шифрування з урахуванням цього — дорівнює 2.
# 
# pos = ord('v') - ord('a')  # 21
# pos = (pos + 33) % 26  # 2
# 
# Залишився останній крок, отримати новий символ:
# 
# pos = ord('v') - ord('a')  # 21
# pos = (pos + 33) % 26  # 2
# new_char = chr(pos + ord("a"))  # 'c'
# 
# Символ v зі зміщенням 33 шифрується символом c.
# 
# Тести перевіряють та кодують наступні рядки:
# 
# "Hello my little friends!", offset = 37,
# "Hello world!", offset = 7

message = input("Enter a message: ")
offset = int(input("Enter the offset: "))
encoded_message = ""
for ch in message:
    new_ch=ch
    if ch >= 'a' and ord(ch)<ord('a')+26:
        new_ch = chr(ord('a')+(ord(ch)-ord('a')+offset)%26)
    if ch >= 'A' and ord(ch)<ord('A')+26:
        new_ch = chr(ord('A')+(ord(ch)-ord('A')+offset)%26)
    encoded_message += new_ch


# 15. Напишіть програму, яка буде виконувати найпростіші математичні операції з числами послідовно, 
# приймаючи від користувача операнди (числа) та оператор.
# 
# Умови для цієї задачі
# 
# Додаток працює з цілими та дійсними числами.
# Додаток вміє виконувати такі математичні операції:
# ДОДАВАННЯ (+)
# ВІДНІМАННЯ(-)
# МНОЖЕННЯ (*)
# ДІЛЕННЯ (/)
# Програма приймає один операнд або один оператор за один цикл запит-відповідь.
# Всі операції програма виконує в порядку надходження — одну за одною.
# Програма виводить результат обчислень, коли отримує від користувача символ =.
# Додаток закінчує роботу після того, як виведе результат обчислення.
# Користувач по черзі вводить числа та оператори.
# Якщо користувач вводить оператор двічі поспіль, він отримує повідомлення про помилку і може ввести повторно.
# Якщо користувач вводить число двічі поспіль, він отримує повідомлення про помилку і може ввести повторно.
# Додаток коректно опрацьовує ситуацію некоректного введення (exception).
# Початкові змінні:
# 
# result = None
# operand = None
# operator = None
# wait_for_number = True
# result — сюди поміщаємо підсумковий результат operand — завжди зберігає поточне число operator — рядковий параметр, може містити чотири значення, "+", "-", "*", "/" wait_for_number — прапорець, який вказує, що очікують на вводі оператор (operator) або операнд (operand)
# 
# Приклад виконання програми:
# 
# >>> 3
# >>> +
# >>> 3
# >>> 2
# 2 is not '+' or '-' or '/' or '*'. Try again
# >>> -
# >>> -
# '-' is not a number. Try again.
# >>> 5
# >>> *
# >>> 3
# >>> =
# Result: 3.0
# Тестові послідовності:
# 
# Перша: ["10", "+", "5", "6", "/", "3", "-", "a", "2", "*", "6", "= "], результат 18.0
# Друга: ["2", "3", "-", "1", "+", "10", "*", "2", "="], результат 22.0 

result = None
operand = None
operator = None
wait_for_number = True
OPERATORS = ["+","-","/","*"]
        
while True:
    if wait_for_number:
        while True:
            operand = input(">>>")
            try:
                operand = float(operand)
            except ValueError:
                print(f"{operand} is is not a number. Try again")
                continue
            else:
                if operator == '/':
                    result /= operand
                elif operator == '*':
                    result *= operand
                elif operator == '+':
                    result += operand
                elif operator == '-':
                    result -= operand
                else:    
                    result = operand
                break
        wait_for_number = False
    else:
        operator = input(">>>")
        if operator == '=':
            break
        if operator in OPERATORS:
            wait_for_number = True
        else: 
            print(f"{operator} is not '+' or '-' or '/' or '*'. Try again")
            continue
    
print (result)  

