# 4. У Python існує рядкова функція isdigit(). Ця функція повертає True, якщо всі символи в рядку 
# є цифрами, і є принаймні один символ, інакше — False. Напишіть функцію з ім'ям is_integer, 
# яка розширюватиме функціональність isdigit(). При перевірці рядка необхідно ігнорувати 
# початкові та кінцеві прогалини в рядку. Після виключення зайвих прогалин рядок вважається 
# таким, що представляє ціле число, якщо:

# її довжина більша або дорівнює одному символу
# вона повністю складається з цифр
# передбачити виняток, що, можливо, є початковий знак "+" або "-", після якого мають йти цифри

import re

def is_integer(s):

    s = s.strip()

    if len(s) == 0:
        return False
    
    pattern = r"^[+|-]?\d+"
    result = re.findall(pattern, s)
    if len(result) == 0:
        return False
    if len(s) == len(result[0]):
        return True
    return False

# 5. Дуже часто люди у своїх повідомленнях не ставлять великі літери, особливо це 
# стало масовим явищем в еру мобільних. пристроїв. Розробіть функцію capital_text, 
# яка прийматиме на вхід рядок з текстом і повертатиме рядок з відновленими 
# великими літерами.

# Функція повинна:

# зробити великою першу літеру в рядку, попри прогалини
# зробити великою першу літеру після точки, попри прогалини
# зробити великою першу літеру після знака оклику, попри прогалини
# зробити великою першу літеру після знака питання, попри прогалини

def capital_text(s):
    sentences = s
    for delim in ('.', '!', '?'):
        sentences = sentences.split(delim)
            
        for i in range(len(sentences)):
            # print(sentence)
            words = sentences[i].split()
            if len(words) < 1:
                continue
            words[0] = words[0].title()
            sentences[i] = ' '.join(words)
        sentences = (delim + ' ').join(sentences)
    return sentences
            
    
# string = " niels Bohr was born to Christian Bohr (1858-1911), a professor of physiology at the University of Copenhagen,"\
#          "twice a candidate for the Nobel Prize in physiology and medicine! and Ellen Adler (" \
#          "1860-1930)??? daughter of the influential and very wealthy Jewish banker and liberal parliamentarian David " \
#          "Baruch Adler (1826—1878) and Jenny Raphael (1830-1902) of the British Jewish " \
#          "Raphael Raphael & sons[en][11] of the British Jewish banking dynasty. Bohr's parents married in 1881."
# print(f'{string} \n\n{capital_text(string)}')


# 6. Реалізуйте функцію solve_riddle(riddle, word_length, start_letter, reverse=False) для знаходження 
# слова, що шукається в рядку ребуса.

# Параметри функції:

# riddle - рядок із зашифрованим словом.
# word_length – довжина зашифрованого слова.
# start_letter - літера, з якої починається слово (мається на увазі, що до початку слова літера 
# не зустрічається в рядку).
# reverse - вказує, у якому порядку записане слово. За замовчуванням — в прямому. Для значення 
# True слово зашифроване у зворотньому порядку, наприклад, у рядку 'mi1rewopret' зашифроване слово 'power'.
# Функція повинна повертати перше знайдене слово. Якщо слово не знайдене, повернути пустий рядок.


def solve_riddle(riddle, word_length, start_letter, reverse=False):

    if reverse:
        riddle = riddle[::-1]

    pos = riddle.find(start_letter)
    
    result = "" if pos<0 else riddle[pos : pos+word_length]
    return result

# print(solve_riddle('mi1rewopret',5,'p',True))


# 7. У четвертому модулі розв'язували завдання нормалізації даних. Розширимо її.

# При аналізі даних часто виникає необхідність позбавитися екстремальних значень, перш ніж почати 
# працювати з даними далі. Напишіть функцію data_preparation, яка приймає набір даних, список 
# списків (Приклад: [[1,2,3],[3,4], [5,6]]).

# Функція повинна видаляти з переданих списків найбільше і найменше значення, але якщо розмір 
# списку понад два елементи. Після видалення даних з кожного списку необхідно злити їх разом 
# в один список, відсортувати його за зменшенням та повернути отриманий список як результат 
# (Для прикладу вище результат буде наступним: [6, 5, 4, 3, 2]).


def data_preparation(list_data):

    result = []
    for item in list_data:
        if len(item)>2:
            item.sort()
            item.pop(0)
            item.pop(-1)
        result.extend(item)
    result.sort(reverse=True)
    return result
        
print(data_preparation([[1, 3, 4, 2],[4, 5, 2, 3, 1],[37],[28, 24],[9,8,15]]))


# 8. Підсумкове завдання модуля два було на обчислення арифметичного виразу. У задачі на 
# повторення ми підемо трохи іншим шляхом і виконаємо схоже завдання, одночасно закріпивши 
# знання роботи зі рядками та списками. Розбиття рядка на лексеми є процес перетворення 
# вихідного рядка в список з підрядків, званих лексемами (token).

# В арифметичному виразі лексемами є: оператори, числа та дужки. Операторами у нас будуть 
# такі символи: *, /, - та +. Оператори та дужки легко виділити у рядку — вони складаються 
# з одного символу і ніколи не є частиною інших лексем. Числа виділити складніше, оскільки 
# ці лексеми можуть складатися з кількох символів. Тому будь-яка безперервна послідовність 
# цифр — це одна числова лексема.

# Напишіть функцію, яка приймає параметр рядок, що містить математичний вираз, і перетворює 
# його в список лексем. Кожна лексема має бути або оператором, або числом, або дужкою.

# Приклад:

# "2+ 34-5 * 3" => ['2', '+', '34', '-', '5', '*', '3']
# З метою спрощення вважаємо, що числа можуть бути тільки цілими, і вхідний рядок завжди 
# міститиме математичний вираз, що складається з дужок, чисел та операторів.

# Зверніть увагу, що лексеми можуть відокремлюватися один від одного різною кількістю прогалин, 
# а можуть і не відокремлюватися зовсім. Прогалини не є лексемами та до підсумкового списку 
# потрапити не повинні.


import re

def token_parser(s):
    print(s)
    patt = r"(\d+|[-+*=/()]+)"
    res = re.findall(patt, s)
    print(res)
    return res
    
print(token_parser)


# 9. Підсписком (sublist) називають список, що є складовою більшого списку. Підсписок може 
# містити один елемент, множину елементів або бути порожнім.

# Наприклад, [1], [2], [3] та [4] є підсписками списку [1, 2, 3, 4]. Список [2, 3] також 
# входить до складу [1, 2, 3, 4], але при цьому список [2, 4] не є підсписком [1, 2, 3, 4], 
# оскільки у вихідному списку числа 2 і 4 не є сусідами.

# Порожній список є підсписком будь-якого списку.

# Напишіть функцію all_sub_lists, що повертає список, який містить всі можливі підсписки 
# заданого.

# Наприклад, якщо функції передано аргумент список [1, 2, 3], то функція має повернути 
# наступний список: [[], [1], [2], [3], [1, 2], [2, 3], [1, 2, 3]].

# Функція all_sub_lists повинна повертати щонайменше один список з порожнім підсписком [[]].


def all_sub_lists(data):
    result = [[]]
    for i in range(len(data)):
        for j in range(len(data)-i):
            result.append(data[j:j+i+1])
    return result


# 10. При роботі веб-сервісів спілкування, за протоколом HTTP, найчастіше відбувається в форматі 
# JSON. І надсилання даних на сервер при запиті POST - це необхідність використовувати словник, 
# оскільки структура формату JSON ідентична словнику Python.

# Реалізуйте допоміжну функцію, яка формуватиме запит на сервер у вигляді словника. Дана функція 
# make_request(keys, values) приймає два параметри у вигляді списків. Функція повинна створити 
# словник із ключами з списку keys та значеннями зі списку values.

# Порядок відповідності збігається з індексами списків keys та values.
# Якщо довжина keys та values не збігаються, поверніть порожній словник.


def make_request(keys, values):
    result = {}
    if len(keys)==len(values):
        for i in range(len(keys)):
            result[keys[i]] = values[i]
    return result


# 11. Як ви знаєте, раніше телефони були з кнопками, та й зараз вони є подекуди у вжитку. 
# Тоді текстові повідомлення набиралися за допомогою цифрових кнопок. Як інженери телефонів 
# створили набір тексту? Рішення було в тому, що одна кнопка була асоційована одночасно з 
# декількома літерами, а вибір залежав від кількості натискань на кнопку. Одноразове 
# натискання призводило до появи першої літери у відповідному цій кнопці списку, наступні 
# натискання змінювали її на наступну.

# Символи, що відповідають кнопкам на телефонах

# Кнопка	Символи
# 1	. , ? ! :
# 2	A B C
# 3	D E F
# 4	G H I
# 5	J K L
# 6	M N O
# 7	P Q R S
# 8	T U V
# 9	W X Y Z
# 0	Пробіл
# Напишіть функцію sequence_buttons, що показує послідовність кнопок, яку необхідно натиснути, 
# щоб на екрані телефону з'явився текст, введений користувачем.

# Створіть словник, який відповідає символам з кнопками, які потрібно натиснути.

# Приклад: якщо функції sequence_buttons передати рядок "Hello, World!", функція повинна 
# повернути "4433555555666110966677755531111".

# Вимоги:

# функція коректно обробляє малі та великі літери.
# функція ігнорує символи, що не входять до зазначеного списку

DICT_PHONE = {'1':'.,?!:', '2':'ABC', '3':'DEF','4':'GHI', '5':'JKL', '6':'MNO', '7':'PQRS', '8':'TUV', '9':'WXYZ','0':' ',
            }
def sequence_buttons(string):
    string = string.upper()
    result = ''
    for ch in string:
        for key, value in DICT_PHONE.items():
            print(key, value)
            kod=value.find(ch)
            if kod>=0:
                result += key*(kod+1)
    return result

# print(sequence_buttons('Hi there!'))


# 15. Рекурсія добре підходить до задачі flatentening. Це процес вирівнювання списків, який 
# полягає в позбавленні вкладеної структури. Наприклад список вигляду [1, 2, [3, 4, [5, 6]], 7] 
# має бути перетворений на плоский (flat) список [1, 2, 3, 4, 5, 6, 7]

# Напишіть функцію flatten, яка приймає на вхід список, рекурсивно вирівнюватиме цей 
# список і повертатиме пласку версію списку.

# Для виконання завдання можна дотримуватися наступного алгоритму:

# Якщо вхідний список порожній, то:
#   Повертаємо порожній список
# Якщо перший елемент списку є списком, то:
#   Отримуємо перший список, рекурсивно викликавши функцію з першим елементом списку
#   Отримуємо другий список, рекурсивно викликавши функцію з рештою списку без першого елемента
#   Повертаємо конкатенацію двох списків
# Якщо перший елемент списку не є списком, то:
#   Отримуємо перший список із першого елемента списку
#   Отримуємо другий список, рекурсивно викликавши функцію з рештою списку без першого елемента
#   Повертаємо конкатенацію двох списків


def flatten(data):
    
    if len(data)==0:
        return list()

    if type(data[0]) is list:
        list1 = flatten(data[0])
        data.pop(0)
        list2 = data.copy()
    else:
        list1 = [data.pop(0)]
        list2 = data.copy()
    return list1 + flatten(list2)
        
        
# print(flatten([1, 2, [3, 4, [5, 6]], 7]))


# 16. Розберемо просту техніку кодування та декодування на основі серій. Наприклад, у нас є 
# список із повторюваними спостереженнями якоїсь величини, вона може приймати значення 
# X, Y або Z. Значення з'являються у довільному порядку та зберігаємо ми їх у списку 
# ["X", "X", "X", "Z", "Z", "X", "X", "Y", "Y", "Y", "Z", "Z"] або рядку "XXXZZXXYYYZZ".

# Внаслідок чого ми можемо зменшити обсяг інформації, що зберігається? Стиснення можна 
# досягти заміною групи повторюваних значень на одноразове значення та лічильник повторів: 
# ["X", 3, "Z", 2, "X", 2, "Y", 3, "Z", 2]

# Напишіть рекурсивну функцію decode для декодування списку, закодованого цим способом. 
# Як аргумент функція приймає закодований список. Функція має повернути розшифрований 
# список елементів.

def decode(data):
    if len(data) == 0:
        return []
    list1 = [data[0] for _ in range(data[1])]
    data.pop(0)
    data.pop(0)
    return list1+decode(data)


# 17. Повернемося до попереднього завдання та виконаємо зворотне. Напишіть рекурсивну 
# функцію encode для кодування списку або рядка. Як аргумент функція приймає список 
# ( наприклад ["X", "X", "X", "Z", "Z", "X", "X", "Y", "Y", "Y", "Z", "Z" ]) або 
# рядок (наприклад, "XXXZZXXYYYZZ"). Функція повинна повернути закодований список 
# елементів (наприклад ["X", 3, "Z", 2, "X", 2, "Y", 3, "Z", 2]).

def encode(data):

    if len(data)==0:
        return []
    
    i = 0
    result = []
    while  i<len(data) and data[0]==data[i]:
        i += 1      
    result.append(data[0])
    result.append(i)
    return result+encode(data[i:])


print(encode(['X', 'X', 'X', 'Z', 'Z', 'X', 'X', 'Y', 'Y', 'Y', 'Z', 'Z']))
